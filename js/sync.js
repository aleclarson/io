// Generated by CoffeeScript 1.12.4
var Either, StringOrArray, StringOrBuffer, StringOrNumber, UTF8, appendFile, assertType, checkPermissions, copyTree, exists, fs, globby, iconv, isDir, isExecutable, isFile, isLink, isLinkBroken, isReadable, isWritable, match, mkdirp, moveTree, path, readDir, readFile, readLink, readStats, removeTree, rimraf, setMode, writeDir, writeFile, writeLink;

assertType = require("assertType");

Either = require("Either");

rimraf = require("rimraf");

mkdirp = require("mkdirp");

globby = require("globby");

iconv = require("iconv-lite");

path = require("path");

fs = require("fs");

UTF8 = "utf8";

StringOrArray = Either(String, Array);

StringOrBuffer = Either(String, Buffer);

StringOrNumber = Either(String, Number);

isFile = function(filePath) {
  var passed;
  assertType(filePath, String);
  try {
    passed = fs.statSync(filePath).isFile();
  } catch (error1) {}
  return passed === true;
};

readFile = function(filePath, options) {
  var contents;
  if (options == null) {
    options = {};
  }
  assertType(filePath, String);
  assertType(options, Object);
  if (!isFile(filePath)) {
    throw Error("'filePath' must be an existing file: " + path.resolve(filePath));
  }
  contents = fs.readFileSync(filePath);
  if (options.encoding !== null) {
    contents = iconv.decode(contents, options.encoding || UTF8);
    if (contents.charCodeAt(0) === 0xFEFF) {
      contents = contents.slice(1);
    }
  }
  return contents;
};

writeFile = function(filePath, contents, options) {
  if (options == null) {
    options = {};
  }
  assertType(filePath, String);
  assertType(contents, StringOrBuffer);
  assertType(options, Object);
  if (isDir(filePath)) {
    throw Error("'filePath' cannot be a directory: " + path.resolve(filePath));
  }
  writeDir(path.dirname(path.resolve(filePath)));
  if (!Buffer.isBuffer(contents)) {
    if (options.encoding == null) {
      options.encoding = UTF8;
    }
  }
  contents = iconv.encode(contents, options.encoding);
  fs.writeFileSync(filePath, contents, options);
};

appendFile = function(filePath, contents) {
  assertType(filePath, String);
  assertType(contents, StringOrBuffer);
  if (isDir(filePath)) {
    throw Error("'filePath' cannot be a directory: " + path.resolve(filePath));
  }
  if (!exists(filePath)) {
    return writeFile(filePath, contents);
  }
  if (!Buffer.isBuffer(contents)) {
    if (options.encoding == null) {
      options.encoding = UTF8;
    }
  }
  contents = iconv.encode(contents, options.encoding);
  fs.appendFileSync(filePath, contents, options);
};

isDir = function(filePath) {
  var passed;
  assertType(filePath, String);
  try {
    passed = fs.statSync(filePath).isDirectory();
  } catch (error1) {}
  return passed === true;
};

readDir = function(dirPath) {
  assertType(dirPath, String);
  if (!isDir(dirPath)) {
    throw Error("'dirPath' must be an existing directory: " + path.resolve(dirPath));
  }
  return fs.readdirSync(dirPath);
};

writeDir = function(dirPath) {
  assertType(dirPath, String);
  if (isFile(dirPath)) {
    throw Error("'dirPath' must be a directory or not exist: " + path.resolve(dirPath));
  }
  return mkdirp.sync(dirPath);
};

isLinkBroken = function(linkPath) {
  var linkParent, targetPath;
  assertType(linkPath, String);
  if (!isLink(linkPath)) {
    throw Error("'linkPath' must be a symbolic link: " + path.resolve(linkPath));
  }
  linkParent = path.dirname(linkPath);
  targetPath = path.resolve(linkParent, readLink(linkPath));
  return !exists(targetPath);
};

isLink = function(filePath) {
  var passed;
  assertType(filePath, String);
  try {
    passed = fs.lstatSync(filePath).isSymbolicLink();
  } catch (error1) {}
  return passed === true;
};

readLink = function(linkPath) {
  assertType(linkPath, String);
  return fs.readlinkSync(linkPath);
};

writeLink = function(linkPath, targetPath) {
  assertType(linkPath, String);
  if (isLink(linkPath)) {
    rimraf.sync(linkPath);
  } else if (exists(linkPath)) {
    throw Error("'linkPath' must be a symlink or not exist: " + path.resolve(linkPath));
  }
  assertType(targetPath, String);
  targetPath = path.resolve(linkPath, targetPath);
  if (!exists(targetPath)) {
    throw Error("'targetPath' must exist: " + targetPath);
  }
  fs.symlinkSync(targetPath, linkPath);
};

checkPermissions = function(mode) {
  return function(filePath) {
    var error;
    assertType(filePath, String);
    try {
      fs.accessSync(filePath, mode);
    } catch (error1) {
      error = error1;
      return false;
    }
    return true;
  };
};

isReadable = checkPermissions(fs.R_OK);

isWritable = checkPermissions(fs.W_OK);

isExecutable = checkPermissions(fs.X_OK);

exists = function(filePath) {
  var stats;
  assertType(filePath, String);
  try {
    stats = fs.lstatSync(filePath);
  } catch (error1) {}
  return stats !== void 0;
};

match = function(globs, options) {
  assertType(globs, StringOrArray);
  assertType(options, Object.Maybe);
  return globby.sync(globs, options);
};

readStats = function(filePath) {
  var error;
  assertType(filePath, String);
  try {
    return fs.lstatSync(filePath);
  } catch (error1) {
    error = error1;
    throw Error("'filePath' does not exist: " + path.resolve(filePath));
  }
};

setMode = function(filePath, mode) {
  if (mode == null) {
    mode = "755";
  }
  assertType(filePath, String);
  if (!exists(filePath)) {
    throw Error("'filePath' must exist: " + path.resolve(filePath));
  }
  assertType(mode, StringOrNumber);
  if (typeof mode === "string") {
    mode = parseInt(mode, 8);
  }
  fs.chmodSync(filePath, mode);
};

copyTree = function(fromPath, toPath, options) {
  if (options == null) {
    options = {};
  }
  assertType(fromPath, String);
  assertType(toPath, String);
  assertType(options, Object);
  fromPath = path.resolve(fromPath);
  toPath = path.resolve(toPath);
  if (!exists(fromPath)) {
    throw Error("Expected 'fromPath' to exist: " + path.resolve(fromPath));
  }
  if (isDir(fromPath)) {
    if (!options.testRun) {
      writeDir(toPath);
    } else if (!exists(toPath)) {
      console.log("Creating '" + (path.resolve(toPath)) + "'");
    }
    return readDir(fromPath).forEach(function(child) {
      var fromChild, toChild;
      fromChild = path.join(fromPath, child);
      if (isDir(fromChild) && !options.recursive) {
        return;
      }
      toChild = path.join(toPath, child);
      return copyTree(fromChild, toChild, options);
    });
  }
  if (!(options.force || !exists(toPath))) {
    throw Error("Expected 'toPath' to not exist: '" + (path.resolve(toPath)) + "'");
  }
  if (!options.testRun) {
    writeFile(toPath, readFile(fromPath));
  } else {
    console.log("Copying '" + (path.resolve(fromPath)) + "' to '" + (path.resolve(toPath)) + "'");
  }
};

moveTree = function(fromPath, toPath) {
  assertType(fromPath, String);
  assertType(toPath, String);
  if (!exists(fromPath)) {
    throw Error("Expected 'fromPath' to exist: '" + (path.resolve(fromPath)) + "'");
  }
  if (exists(toPath)) {
    throw Error("Expected 'toPath' to not exist: '" + (path.resolve(toPath)) + "'");
  }
  writeDir(path.dirname(path.resolve(toPath)));
  fs.renameSync(fromPath, toPath);
};

removeTree = function(filePath) {
  assertType(filePath, String);
  if (exists(filePath)) {
    rimraf.sync(filePath);
    return true;
  }
  return false;
};

module.exports = {
  isFile: isFile,
  read: readFile,
  write: writeFile,
  append: appendFile,
  isDir: isDir,
  readDir: readDir,
  writeDir: writeDir,
  isLinkBroken: isLinkBroken,
  isLink: isLink,
  readLink: readLink,
  writeLink: writeLink,
  isReadable: isReadable,
  isWritable: isWritable,
  isExecutable: isExecutable,
  exists: exists,
  match: match,
  readStats: readStats,
  setMode: setMode,
  copy: copyTree,
  move: moveTree,
  remove: removeTree,
  link: writeLink,
  chmod: setMode,
  stats: readStats,
  makeDir: writeDir
};
